from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from schemas.user import UserCreate, UserResponse, UserLogin, UserLoginResponse
from services.auth import get_password_hash, verify_password, create_access_token


async def get_user_by_username(username: str, db_session: AsyncSession) -> User | None:
    result = await db_session.execute(select(User).filter(User.username == username))
    return result.scalars().first()


async def get_user_by_email(email: str, db_session: AsyncSession) -> User | None:
    result = await db_session.execute(select(User).filter(User.email == email))
    return result.scalars().first()


async def create_user(user: UserCreate, db_session: AsyncSession) -> UserResponse:
    # Check if user email already exists
    existing_user = await get_user_by_username(user.username, db_session)
    if existing_user:
        raise ValueError(
            "Ya existe una cuenta de usuario registrada con este nombre de usuario, inténtelo nuevamente...")

    # Check if user email already exists
    existing_user = await get_user_by_email(user.email, db_session)
    if existing_user:
        raise ValueError(
            "Ya existe una cuenta de usuario registrada con este correo electronico, inténtelo nuevamente...")

    # Hash the password
    hashed_password = get_password_hash(user.password_hash)

    # Create a new User instance
    new_user = User(
        username=user.username,
        email=user.email,
        password_hash=hashed_password
    )

    # Add the user to the session and commit
    db_session.add(new_user)
    await db_session.commit()

    # Refresh the new_user instance to get the ID and other autogenerated fields
    await db_session.refresh(new_user)

    # Return the created user as a response
    return UserResponse.from_orm(new_user)


async def auth_user(user: UserLogin, db_session: AsyncSession) -> UserLoginResponse:
    # Fetch the user by username first, then by email if necessary
    user_data = await get_user_by_username(user.username, db_session)
    if not user_data:
        user_data = await get_user_by_email(user.email, db_session)

    # If no user data found, return a placeholder or simple response for testing
    if not user_data:
        raise ValueError("No se encontró la cuenta de usuario, inténtelo nuevamente...")

    # Verify the password
    if not verify_password(user.password, user_data.password_hash):
        raise ValueError("Contraseña incorrecta, inténtelo nuevamente...")

    user_access_token = create_access_token(data={"user_id": user_data.id})

    # Return user data
    return UserLoginResponse(
        username=user_data.username,
        email=user_data.email,        
        access_token=user_access_token
    )
