from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from models.note import Note
from schemas.note import NoteCreate, NoteUpdate, NoteResponse
import bleach


def sanitize_input(content: str) -> str:
    allowed_tags = ['b', 'i', 'u', 'a', 'p', 'br']
    return bleach.clean(content, tags=allowed_tags, strip=True)


async def get_note_by_id(note_id: int, user_id: int, db_session: AsyncSession):
    result = await db_session.execute(select(Note).where(Note.id == note_id, Note.user_id == user_id))
    return result.scalars().first()


async def get_all_notes(user_id:int, db_session: AsyncSession):
    result = await db_session.execute(select(Note).where(Note.user_id == user_id))
    return [NoteResponse.from_orm(note) for note in result.scalars()]


async def create_note(note: NoteCreate, db_session: AsyncSession, token_payload: dict) -> NoteResponse:
    sanitized_title = sanitize_input(note.title)
    sanitized_content = sanitize_input(note.content)

    new_note = Note(
        user_id=token_payload["user_id"],
        title=sanitized_title,
        content=sanitized_content
    )

    # Add the note to the session and commit
    db_session.add(new_note)

    # Commit the changes
    await db_session.commit()

    # Refresh the new_note instance to get the ID and other autogenerated fields
    await db_session.refresh(new_note)

    # Return the created note as a response
    return NoteResponse.from_orm(new_note)


async def update_note(note_id: int, note: NoteUpdate, db_session: AsyncSession, token_payload: dict) -> NoteResponse:
    # Fetch the note to update
    existing_note = await get_note_by_id(note_id, token_payload["user_id"], db_session)
    if not existing_note:
        raise ValueError("No se encontró la nota")

    sanitized_title = sanitize_input(note.title)
    sanitized_content = sanitize_input(note.content)

    # Update the note fields
    existing_note.title = sanitized_title
    existing_note.content = sanitized_content

    # Commit the changes
    await db_session.commit()

    # Refresh the note instance to reflect updated fields
    await db_session.refresh(existing_note)

    # Return the updated note as a response
    return NoteResponse.from_orm(existing_note)


async def delete_note(note_id: int, db_session: AsyncSession, token_payload: dict):
    # Fetch the note to delete
    existing_note = await get_note_by_id(note_id, token_payload["user_id"], db_session)
    if not existing_note:
        raise ValueError("No se encontró la nota")

    # Delete the note
    await db_session.delete(existing_note)

    #commit the changes
    await db_session.commit()

    # Return confirmation response
    return {"message": "La nota fue eliminada exitosamente"}